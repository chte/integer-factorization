As described in the scope the intention is not to find a new method of factoring integers but instead use existing methods and implement them in a intelligent way.

\subsection{Trial Division}
Trial division is an easy implemented algorithm for finding factors to $N$. Like its name suggests it uses tries to divide $N$ by using a $x > 2$. If the remainder of $N/x = 0$ the factor is a non-trivial factor, if we cannot find a divisor $x$ that gives the remainder $0$ then $N$ is a prime.

The restrictions for the algorithm are easy to find and improve, $N > 1$ and $x > 2$. This can be improved by saying that $N > x$ and since the factors of N cannot be larger than $\sqrt{N}$ we can also say that $\sqrt{N} > x > 2$. Another improvement is to only do tests when $x$ is a prime number. Although trial division is easy to implement and guaranteed to grant an answer it is not efficient for large a $N$.

\subsection{Pollard's Rho}
Pollard rho is a prime factorization algorithm which is based on Floydâ€™s cycle-finding algorithm. The idea of pollard rho algorithm is to iterate a formula until it falls into a cycle. We want to find a $x$ and $y$ where the $x$ makes twice as many iterations as the $y$ using a function $modulo N$ as a generator of a pseudo-random sequence. The $GCD|x - y|$ of $N$ is taken each step, and the GCD reaches $N$ we have not found an answer and the algorithm terminates with a failure.

We can write $N = p * q$, when $x$, which iterates twice as fast as $y$, catches up with $y$ which will happen eventually, at this point factor $p$ will be found. The time it will take cannot be proven matematically and can only be proven by heuristics. If the sequence behaves randomly it would take approximately p steps to find p, which is not very effcient. \cite{avalg} \\

\includegraphics[scale = 0.5]{pollards.png}

The figure above illustrates the Pollard's Rho cycle. The mapping of $x_{i+1}$ is instead replaced with a function $x^2+1$ so that we get $x^2_{i}+1$  $mod$ $N$ the factor $p$ will be found after $O(\sqrt{p})$  $\epsilon$ $O(N^{1/4})$ steps. \cite{avalg}\\

Pollard's rho algorithm can be improved further by implementing Brent's cycle finding method. \cite{brent}

\subsection{Miller-Rabin primality test}
Miller-Rabin primality test is a probabalistics algorithm which determines if the given input $N$ is a prime. It is based on the properties of strong pseudoprimes, given an integer $N$, $N = 2^r * s + 1$ where $s$ is odd, you choose a random number $a$ with the properties $1 \leq a \leq N - 1$. When $a^s \equiv 1$ $mod$ $N$ or $a^{2js} \equiv - 1$ $mod$ $N$ where $0 \leq j \leq r - 1$, if the input number $N$ is a prime it will pass the test with any random number $a$.

Since Miller-Rabin is a probabalistics method it is not completely true that $N$ is a prime simply by passing the test, however the probability that the answer is true when $N$ is a composite number is $1 / 4^{N}$ which grows quickly with $N$. It can be considered a very small trade-off to use a probabalistics method because the algorithm executes at $O(k$ $log^3 N)$ where $k$ is the number of different values of $a$ tested. \cite{miller}